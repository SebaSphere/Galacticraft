package micdoodle8.mods.galacticraft.core.tile;

import micdoodle8.mods.galacticraft.core.Annotations.NetworkedField;
import micdoodle8.mods.galacticraft.core.GCBlockNames;
import micdoodle8.mods.galacticraft.core.Constants;
import micdoodle8.mods.galacticraft.core.blocks.BlockMachineBase;
import micdoodle8.mods.galacticraft.core.energy.item.ItemElectricBase;
import micdoodle8.mods.galacticraft.core.energy.tile.EnergyStorageTile;
import micdoodle8.mods.galacticraft.core.energy.tile.TileBaseElectricBlockWithInventory;
import micdoodle8.mods.galacticraft.core.inventory.ContainerElectricFurnace;
import micdoodle8.mods.galacticraft.core.util.ConfigManagerCore;
import net.minecraft.core.Direction;
import net.minecraft.core.NonNullList;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.TranslatableComponent;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.WorldlyContainer;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.Recipe;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraftforge.common.ForgeHooks;
import net.minecraftforge.fml.LogicalSide;
import net.minecraftforge.registries.ObjectHolder;

import java.util.HashSet;
import java.util.Set;

public class TileEntityElectricFurnace extends TileBaseElectricBlockWithInventory implements WorldlyContainer, IMachineSides, MenuProvider
{
    public static class TileEntityElectricFurnaceT1 extends TileEntityElectricFurnace
    {
        @ObjectHolder(Constants.MOD_ID_CORE + ":" + GCBlockNames.ELECTRIC_FURNACE)
        public static BlockEntityType<TileEntityElectricFurnaceT1> TYPE;

        public TileEntityElectricFurnaceT1()
        {
            super(TYPE);
            this.storage.setMaxExtract(ConfigManagerCore.hardMode.get() ? 60 : 45);
        }
    }

    public static class TileEntityElectricFurnaceT2 extends TileEntityElectricFurnace
    {
        @ObjectHolder(Constants.MOD_ID_CORE + ":" + GCBlockNames.ELECTRIC_ARC_FURNACE)
        public static BlockEntityType<TileEntityElectricFurnaceT2> TYPE;

        public TileEntityElectricFurnaceT2()
        {
            super(TYPE);
            setTier2();
        }
    }

    //The electric furnace is 50% faster than a vanilla Furnace
    //but at a cost of some inefficiency:
    //It uses 46800 gJ to smelt 8 ingots quickly
    //compared with the energy generated by 1 coal which is 38400 gJ
    //
    //The efficiency can be increased using a Tier 2 furnace

    public static int PROCESS_TIME_REQUIRED = 130;

    @NetworkedField(targetSide = LogicalSide.CLIENT)
    public int processTimeRequired = PROCESS_TIME_REQUIRED;

    @NetworkedField(targetSide = LogicalSide.CLIENT)
    public int processTicks = 0;

    public final Set<Player> playersUsing = new HashSet<Player>();

    private boolean initialised = false;

    /*
     * @param tier: 1 = Electric Furnace  2 = Electric Arc Furnace
     */
    public TileEntityElectricFurnace(BlockEntityType<?> type)
    {
        super(type);
        this.initialised = true;
        this.inventory = NonNullList.withSize(4, ItemStack.EMPTY);
    }

    protected void setTier2()
    {
        this.storage.setCapacity(25000);
        this.storage.setMaxExtract(ConfigManagerCore.hardMode.get() ? 90 : 60);
        this.processTimeRequired = 100;
        this.setTierGC(2);
    }

    @Override
    public void tick()
    {
        if (!this.initialised)
        {
            //for version tick compatibility
//            Block b = this.world.getBlockState(this.getPos()).getBlock();
//            if (b == GCBlocks.machineBase)
//            {
//                this.world.setBlockState(this.getPos(), GCBlocks.machineTiered.getDefaultState()/*,s 4*/, 2);
//            }
//            else if (metadata >= 8)
//            {
//                this.setTier2();
//            }
            this.initialised = true;
        }

        super.tick();

        if (!this.level.isClientSide)
        {
            if (this.canProcess())
            {
                if (this.hasEnoughEnergyToRun)
                {
                    //100% extra speed boost for Tier 2 machine if powered by Tier 2 power
                    if (this.tierGC >= 2)
                    {
                        this.processTimeRequired = PROCESS_TIME_REQUIRED / 2 / this.poweredByTierGC;
                    }

                    if (this.processTicks == 0)
                    {
                        this.processTicks = this.processTimeRequired;
                    }
                    else
                    {
                        if (--this.processTicks <= 0)
                        {
                            this.smeltItem();
                            this.processTicks = this.canProcess() ? this.processTimeRequired : 0;
                        }
                    }
                }
                else if (this.processTicks > 0 && this.processTicks < this.processTimeRequired)
                {
                    //Apply a "cooling down" process if the electric furnace runs out of energy while smelting
                    if (this.level.random.nextInt(4) == 0)
                    {
                        this.processTicks++;
                    }
                }
            }
            else
            {
                this.processTicks = 0;
            }
        }
        else
        {
            //Smoother client LogicalSide animation before the networked fields get updated
            if (this.processTicks > 0 && this.processTicks < this.processTimeRequired)
            {
                this.processTicks--;
            }
        }
    }

    /**
     * @return Is this machine able to process its specific task?
     */
    public boolean canProcess()
    {
        ItemStack stack = this.getInventory().get(1);
        if (stack.isEmpty())
        {
            return false;
        }
        Recipe<?> irecipe = this.level.getRecipeManager().getRecipeFor(RecipeType.SMELTING, this, this.level).orElse(null);
        if (irecipe == null)
        {
            return false;
        }
        ItemStack result = irecipe.getResultItem();
        if (!result.isEmpty())
        {
            int burnable = ForgeHooks.getBurnTime(stack);
//            if (burnable >= 200 && burnable < 400 && GalacticraftCore.isPlanetsLoaded) result = new ItemStack(MarsItems.carbonFragments);   //this includes most wooden tools, doors, stairs, boats etc but not saplings and sticks TODO Planets
//            else return false;
            return false;
        }


        if (this.tierGC == 1)
        {
            if (!this.getInventory().get(2).isEmpty())
            {
                return (this.getInventory().get(2).sameItem(result) && this.getInventory().get(2).getCount() < 64);
            }
        }

        //Electric Arc Furnace
        if (this.getInventory().get(2).isEmpty() || this.getInventory().get(3).isEmpty())
        {
            return true;
        }
        int space = 0;
        if (this.getInventory().get(2).sameItem(result))
        {
            space = 64 - this.getInventory().get(2).getCount();
        }
        if (this.getInventory().get(3).sameItem(result))
        {
            space += 64 - this.getInventory().get(3).getCount();
        }
        return space >= 2;
    }

    /**
     * Turn one item from the furnace source stack into the appropriate smelted
     * item in the furnace result stack
     */
    public void smeltItem()
    {
        if (this.canProcess())
        {
            Recipe<?> irecipe = this.level.getRecipeManager().getRecipeFor(RecipeType.SMELTING, this, this.level).orElse(null);
//            ItemStack resultItemStack = FurnaceRecipes.instance().getSmeltingResult(this.getInventory().get(1));
            ItemStack resultItemStack = irecipe.getResultItem();
            boolean doubleResult = false;
            if (this.tierGC > 1)
            {
                String nameSmelted = this.getInventory().get(1).getDescriptionId().toLowerCase();
                if ((resultItemStack.getDescriptionId().toLowerCase().contains("ingot") || resultItemStack.getItem() == Items.QUARTZ) && (nameSmelted.contains("ore") || nameSmelted.contains("raw") || nameSmelted.contains("moon") || nameSmelted.contains("mars") || nameSmelted.contains("shard")))
                {
                    doubleResult = true;
                }
            }

            if (doubleResult)
            {
                int space2 = 0;
                int space3 = 0;
                if (this.getInventory().get(2).isEmpty())
                {
                    this.getInventory().set(2, resultItemStack.copy());
                    this.getInventory().get(2).grow(resultItemStack.getCount());
                    space2 = 2;
                }
                else if (this.getInventory().get(2).sameItem(resultItemStack))
                {
                    space2 = (64 - this.getInventory().get(2).getCount()) / resultItemStack.getCount();
                    if (space2 > 2)
                    {
                        space2 = 2;
                    }
                    this.getInventory().get(2).grow(resultItemStack.getCount() * space2);
                }
                if (space2 < 2)
                {
                    if (this.getInventory().get(3).isEmpty())
                    {
                        this.getInventory().set(3, resultItemStack.copy());
                        if (space2 == 0)
                        {
                            this.getInventory().get(3).grow(resultItemStack.getCount());
                        }
                    }
                    else if (this.getInventory().get(3).sameItem(resultItemStack))
                    {
                        space3 = (64 - this.getInventory().get(3).getCount()) / resultItemStack.getCount();
                        if (space3 > 2 - space2)
                        {
                            space3 = 2 - space2;
                        }
                        this.getInventory().get(3).grow(resultItemStack.getCount() * space3);
                    }
                }
            }
            else if (this.getInventory().get(2).isEmpty())
            {
                this.getInventory().set(2, resultItemStack.copy());
            }
            else if (this.getInventory().get(2).sameItem(resultItemStack))
            {
                this.getInventory().get(2).grow(resultItemStack.getCount());
            }

            this.getInventory().get(1).shrink(1);
        }
    }

    @Override
    public void load(CompoundTag nbt)
    {
        super.load(nbt);
        if (this.storage.getEnergyStoredGC() > EnergyStorageTile.STANDARD_CAPACITY)
        {
            this.setTier2();
            this.initialised = true;
        }
        else
        {
            this.initialised = false;
        }
        this.processTicks = nbt.getInt("smeltingTicks");

        this.readMachineSidesFromNBT(nbt);  //Needed by IMachineSides
    }

    @Override
    public CompoundTag save(CompoundTag nbt)
    {
        if (this.tierGC == 1 && this.storage.getEnergyStoredGC() > EnergyStorageTile.STANDARD_CAPACITY)
        {
            this.storage.setEnergyStored(EnergyStorageTile.STANDARD_CAPACITY);
        }
        super.save(nbt);
        nbt.putInt("smeltingTicks", this.processTicks);

        this.addMachineSidesToNBT(nbt);  //Needed by IMachineSides

        return nbt;
    }

//    @Override
//    public boolean hasCustomName()
//    {
//        return true;
//    }

    /**
     * Returns true if automation is allowed to insert the given stack (ignoring
     * stack size) into the given slot.
     */
    @Override
    public boolean canPlaceItem(int slotID, ItemStack itemStack)
    {
        if (itemStack.isEmpty())
        {
            return false;
        }
        /*!FurnaceRecipes.instance().getSmeltingResult(itemStack).isEmpty() TODO Furnace slots */
        return slotID == 1 || slotID == 0 && ItemElectricBase.isElectricItem(itemStack.getItem());
    }

    @Override
    public int[] getSlotsForFace(Direction side)
    {
        if (this.tierGC == 2)
        {
            return new int[]{0, 1, 2, 3};
        }
        return new int[]{0, 1, 2};
    }

    @Override
    public boolean canPlaceItemThroughFace(int slotID, ItemStack par2ItemStack, Direction par3)
    {
        return this.canPlaceItem(slotID, par2ItemStack);
    }

    @Override
    public boolean canTakeItemThroughFace(int slotID, ItemStack par2ItemStack, Direction par3)
    {
        return slotID == 2 || this.tierGC == 2 && slotID == 3;
    }

    @Override
    public boolean shouldUseEnergy()
    {
        return this.canProcess();
    }

//    @Override
//    public boolean hasCustomName()
//    {
//        return false;
//    }

    @Override
    public Direction getFront()
    {
        return BlockMachineBase.getFront(this.level.getBlockState(getBlockPos()));
    }

    @Override
    public Direction getElectricInputDirection()
    {
        switch (this.getSide(MachineSide.ELECTRIC_IN))
        {
        case RIGHT:
            return getFront().getCounterClockWise();
        case REAR:
            return getFront().getOpposite();
        case TOP:
            return Direction.UP;
        case BOTTOM:
            return Direction.DOWN;
        case LEFT:
        default:
            return getFront().getClockWise();
        }
    }

    @Override
    public void startOpen(Player player)
    {
        playersUsing.add(player);
    }

    @Override
    public void stopOpen(Player player)
    {
        playersUsing.remove(player);
    }

    //------------------
    //Added these methods and field to implement IMachineSides properly 
    //------------------
    @Override
    public MachineSide[] listConfigurableSides()
    {
        return new MachineSide[]{MachineSide.ELECTRIC_IN};
    }

    @Override
    public Face[] listDefaultFaces()
    {
        return new Face[]{Face.LEFT};
    }

    private MachineSidePack[] machineSides;

    @Override
    public synchronized MachineSidePack[] getAllMachineSides()
    {
        if (this.machineSides == null)
        {
            this.initialiseSides();
        }

        return this.machineSides;
    }

    @Override
    public void setupMachineSides(int length)
    {
        this.machineSides = new MachineSidePack[length];
    }

    @Override
    public void onLoad()
    {
        this.clientOnLoad();
    }

    @Override
    public IMachineSidesProperties getConfigurationType()
    {
        return IMachineSidesProperties.TWOFACES_HORIZ;
    }
    //------------------END OF IMachineSides implementation

    @Override
    public AbstractContainerMenu createMenu(int containerId, Inventory playerInv, Player player)
    {
        return new ContainerElectricFurnace(containerId, playerInv, this);
    }

    @Override
    public Component getDisplayName()
    {
        return new TranslatableComponent("container.electric_furnace");
    }
}
